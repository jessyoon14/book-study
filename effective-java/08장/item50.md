# 50. 적시에 방어적 복사본을 만들라

자바는 안전한 언어다

- 네이티브 메서드를 사용하지 않아서 C/C++에서 발생하는 buffer overrun, array overrun, wild pointer 등 메모리 충돌 오류가 발생하지 않는다

그러나 클래스의 침범은 막아야 한다!

<aside>
💡 클라이언트가 클래스 불변식을 깨뜨리려고 노력한다고 가정하고 방어적으로 프로그래밍해라!

</aside>

### 객체 수정

- 객체의 허락 없이는 외부에서 내부를 수정할 수 없어야 한다
    - 주의: 가변 객체 참조를 final로 선언해도, 참조된 객체를 바꿀 수 있다! → 이 목적이라면 불변 객체를 써라!
        
        ```java
        public final class Period {
        	private final Date start;
        	private final Date end;
        }
        
        Date start = new Date();
        Date end = new Date();
        Period p = new Period(start, end);
        start.setYear(2022); // 객체가 변경됨!!!!
        ```
        
        - 자바 8부터 immutable한 Instant, LocalDateTime, ZonedDateTime 사용하면 된다
        - 가변인 Date는 낡았으니 더이상 사용하지 말라

### 방어적 복사

```java
// 생성자
public Period(Date start, Date end) {
	this.start = new Date(start.getTime());
	this.end = new Date(end.getTime());
	... // start < end인 것 확인
}

// 접근자
public Date start() {
	return new Date(start.getTime());
}
```

- 객체 내부를 외부 공격으로부터 보호하려면 생성자가 받은 가변 매개변수를 모두 defensive copy해야 한다 (인스턴스 내부에서는 전부 복사본 사용)
- 반드시 방어적 복사본을 먼저 만든 후에 매개변수 유효성 검사를 해야한다 (multithreading 경우 대비)
    - TOCTOU (Time of check / Time of use 공격)
- 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들때 clone()을 사용하지 말라
    - Date.clone()말고 새로 Date를 생성해야 한다
    - input 객체가 Date의 악의적 하위 클래스일 수도 있다
- 접근자에서도 내부 객체(가변 필드)를 그대로 리턴하지 말고 의 방어적 복사본을 반환
    - 접근자에서는 clone으로 방어적 복사를 해도 되지만, 일반적으로 생성자나 정적 팩터리를 쓰는게 좋다
    - 내부에서 사용하는 배열을 클라이언트에 반환할 때는 항상 방어적 복사!
- 이렇게 세가지를 지키면 완벽한 불변 클래스가 되어 악의적인 사용자도 절대 불변식 (start < end)을 깨는 객체를 만들 수 없다
- 그외
    - 클라이언트가 제공한 객체를 내부 자료구조에 보관해야 할 때, 그 객체가 나중에 변경되는 것까지 고려해서 방어적 복사를 할지 고민 (문제가 생길 수 있다면 방어적 복사해야함)
        - 예시) 클라이언트가 준 객체를 Map의 key로 사용할 경우

→ 되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어든다

(Date말고 Instant 사용!)

### 생략 가능할 때

방어적 복사는 성능을 저하한다

- 클라이언트를 신뢰할 수 있을 때
    - 호출자가 객체 내부를 수정하지 않을 것이라 확신할 수 있을 때 (ex. 같은 패키지 내부)
- 불변식이 깨져도 영향이 호출한 클라이언트로 국한될 때 (깨져도 클라이언트의 책임)
    - 클라이언트가 가변 객체의 통제권을 넘겨줄 때 → 호출자를 믿어야하므로 공격에 취약하다 (이래서 러스트를 쓰는군)
    

### 고민

보안을 생각하면서 코딩하는 것은 정말 정말 어려운 일이었어.

근데 이건 다 라이브러리를 제공할 때 신경 써야하는 것이지, 일반적인 백엔드를 짤 때는 불변 객체를 만들일이 그렇게 많지 않은 것 같아서, 방어적 복사를 별로 사용하지 않을 것 같다. 무조건 불변이어야 할 때만 쓸텐데, 이때도 코드의 명확하도록 naming에 신경을 많이 써야할 것 같다. 오히려 방어적 복사를 쓴다는 사실을 잊으면 나는 이 객체를 변경한다고 생각하는데 변경이 안되는 문제가 일어나니까.

지금까지 deprecated된 것도 무시하고 다 썼는데, 다 이유가 있어서 deprecate된거니까 이제 쓰면 안되겠다.

라이브러리: 클라리언트를 절대 믿지 말라

대학생 프로젝트 수준의 백엔드: 메서드 호출자에게 많은 것을 기대하며 메서드를 기본 구현만 하도록 작성 

근데 기업 수준의 백엔드에서는 이 두가지를 상충해야 한다 (남이 이 메서드를 잘못 쓸 수 있으니 많은 검증과 방어적 복사를 하되, 누군가 악의를 가지고 쓸 것은 아니니 적당이 효율적으로)