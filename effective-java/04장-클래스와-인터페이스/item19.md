# 19. 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라

상속용 문서화: **자기사용**

상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서화 필요

예시

```java
a() { b(); ...}
b() {...} // 재정의 가능 (public, protected 메서드 중 final 아닌 모든 메서드)
```

이 경우에는 a()에 재정의 가능한 b()를 호출함 + 순서 + 호출 결과의 영향을 명시해야 함

참고: `@implSpec` 태그 (javadoc이 Implementation Requirements 코멘트 헤더를 생성해줌)

### 최적화를 위한 protected method 제공

최적화를 쉽게 하려면, 클래스의 내부 동작 과정 중간에 끼어들 수 있는 hook을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.

→ 그러면 최적화 할 때 이 protected 메서드만 override 해주면 됨

그러나, protected 메서드는 각각 내부 구현이므로 가능한 적어야 한다!

protected가 너무 없으면 상속받을때 불편할 수 있다.

고로, 클래스를 만들고, 세 개 정도의 하위 클래스를 만들면서 이때 필요한 부분을 protected로 놓는게 가장 좋다.

### 상속 가능한 클래스가 지켜야하는 것들

1. 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다
    1. 상위 클래스 생성자가 하위 클래스보다 먼저 실행되기 때문에 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다 → 재정의한 메서드가 하위 클래스 생성자에서 초기화되는 값에 의존한다면 오작동
    2. private, final, static 메서드는 재정의가 불가능하니 생성자에서 안심하고 호출해도 된다

특이사항: Cloneable이나 Serializable 인터페이스를 구현한 클래스는 상속 불가능하게 설계하는 것이 좋다

이유: clone, readObject는 생성자와 비슷한 효과 (새 객체 생성)

⇒ clone, readObject 둘 다 직접적/간접적으로 재정의 가능 메서드를 호출하면 안된다

⇒ Serializable → readResolve, writeReplace는 private 아닌 protected 여야 한다 (private이면 하위 클래스에서 무시하기 때문)

⇒ 이 과정에서 오작동이 많이 일어나므로 비추천

그래서.. 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 제약이 아주 많다!

그러니까 버그를 방지하기 위해서, 상속용으로 설계하지 않은 클래스는 상속을 금지하라!

### 상속을 금지하는 방법

1. final class (쉬움)
2. 모든 생성자를 private / package-private 으로 선언하고 public 정적 팩터리 만들기
    1. 내부에서 다양한 하위 클래스를 만들어 사용 가능